#include "main.h"

#include <algorithm>
#include <deque>
#include <list>
#include <map>
#include <vector>

using namespace std;

#define STRINGIFY(s) #s
#define TEST_ANSWER(tag, yourAnswer, theirAnswer) std::cout << tag << "\nyour: " << yourAnswer << "\nthem: " << theirAnswer << '\n';
#define PRINT_INPUT_SIZE(input) \
    std::cout << STRINGIFY(input) << " params: " << input.params.size() << " args: " << input.args.size() << '\n';

// based off of HackerRank input files
struct FileInput {
    std::vector<std::string> args;
    std::vector<std::string> params;
};

FileInput getVectorizedFileInput(const std::string& filepath) {
    std::string inputstring = mgcp::FileHelper::ReadFile(filepath);
    std::vector<std::string> inputsplit = mgcp::SplitString(inputstring, '\n');

    FileInput input;
    input.params = mgcp::SplitString(inputsplit[0], ' ');
    input.args = mgcp::SplitString(inputsplit[1], ' ');
    return input;
}

int activityNotifications(vector<int> expenditure, int d) {
    vector<int> roll;
    int a = 0;
    for (int i = 0; i < d; ++i) {
        roll.push_back(expenditure[i]);
    }
    sort(roll.begin(), roll.end(), [](int a, int b) { return a < b; });

    for (int i = d; i < expenditure.size(); ++i) {
        const int front = expenditure[i - d];
        const int c = expenditure[i];
        float median;
        if (d % 2 == 1) {
            median = roll[floor(d / 2)];
        } else {
            int index = d / 2;
            median = ((float)(roll[index] + roll[index - 1])) / 2;
        }
        // cout << "median: " << median << " c: " << c << " front: " << front << '\n';
        if (c >= median * 2) {
            a++;
        }
        // for (int &j : roll) cout << "j: " << j << '\n';
        if (i < expenditure.size() - 1) {
            int next = expenditure[i + 1];
            for (int k = roll.size() - 1; k >= 0; --k) {
                if (front == roll[k]) {
                    roll[k] = next;
                    if (k + 1 < roll.size() && roll[k] > roll[k + 1]) {
                        while (k + 1 < roll.size() && roll[k] > roll[k + 1]) {
                            swap(roll[k], roll[k + 1]);
                            ++k;
                        }
                    } else {
                        if (k >= 1 && roll[k] < roll[k - 1]) {
                            while (k - 1 >= 0 && roll[k] < roll[k - 1]) {
                                swap(roll[k], roll[k - 1]);
                                --k;
                            }
                        }
                    }
                    break;
                }
            }
        }
    }
    return a;
}

int activityNotifications2(vector<int> expenditure, int d) {
    list<int> roll;
    int a = 0;
    int i = 0;

    for (i = 0; i < d; ++i) roll.push_back(expenditure[i]);

    roll.sort([](const int& a, const int& b) { return a < b; });
    // sort(roll.begin(), roll.end(), [](int a, int b) { return a < b; });

    auto medianPtr = roll.begin();
    int midIndex = d % 2 == 1 ? d / 2 : d / 2 - 1;
    for (i = 0; i < midIndex; ++i) medianPtr++;
    // cout << "median: " << *medianPtr << " medianPtr+1: " << *(++medianPtr) << '\n';

    for (i = d; i < expenditure.size(); ++i) {
        const int front = expenditure[i - d];
        const int c = expenditure[i];

        float median;
        if (d % 2 == 1) {
            median = *medianPtr;
        } else {
            auto nextPtr = medianPtr;
            median = ((float)(*medianPtr + *(++nextPtr))) / 2;
        }

        // cout << "median: " << median << " c: " << c << " front: " << front << '\n';

        if (c >= median * 2) {
            a++;
        }

        // for (int& j : roll) cout << "j: " << j << '\n';

        if (i < expenditure.size() - 1) {
            int next = expenditure[i + 1];

            bool erased = false;
            bool inserted = false;
            int medcount = 0;

            for (auto itr = roll.begin(); itr != roll.end(); ++itr, ++medcount) {
                int current = *itr;
                if (front == current) {
                    roll.erase(itr);
                    erased = true;
                } else if (next <= current) {
                    roll.insert(itr, next);
                    inserted = true;
                }
                if (medcount == midIndex) medianPtr = itr;
                if (erased && inserted) break;
            }
            if (!inserted) {
                roll.push_back(next);
                ++medianPtr;
            }
        }
    }
    cout << "answer: " << a << '\n';
    return a;
}

float getMedian(int d, vector<int>& roll) {
    int middle = d % 2 == 1 ? (d / 2) + 1 : (d / 2);
    int count = 0;
    int prevIndexWithValue = -1;
    for (int i = 0; i < roll.size(); ++i) {
        count += roll[i];
        if (count >= middle) {
            if (d % 2 == 1) {
                return i;
            } else {
                if (count > middle) {
                    return i;
                } else {
                    for (int j = i + 1; j < roll.size(); ++j) {
                        if (roll[j] > 0) {
                            // cout << "i: " << i << " j: " << j << '\n';
                            return float(j + i) / 2;
                        }
                    }
                }
            }
        }
        if (roll[i] > 0) prevIndexWithValue = i;
    }
    return -1;
}

int activityNotifications3(vector<int> expenditure, int d) {
    const int max = 200;
    vector<int> roll(max, 0);
    int a = 0;

    for (int i = 0; i < d; ++i) {
        const int c = expenditure[i];
        ++roll[c];
    }

    for (int i = d; i < expenditure.size(); ++i) {
        const int front = expenditure[i - d];
        const int c = expenditure[i];
        float median = getMedian(d, roll);
        if (c >= median * 2) {
            a++;
        }
        --roll[front];
        ++roll[c];
    }
    return a;
}

struct TestFileInput {
    TestFileInput(FileInput fi) {
        for (std::string& s : fi.args) args.push_back(std::stoi(s));
        for (std::string& s : fi.params) params.push_back(std::stoi(s));
    }
    std::vector<int> args;
    std::vector<int> params;
};

int main(int argc, char* argv[]) {
    const std::string baseFilePath = "./inputs/";
    FileInput input = getVectorizedFileInput(baseFilePath + "test01.txt");
    PRINT_INPUT_SIZE(input);

    const std::string baseFilePath2 = "./_logs/hacker_rank/interview_prep_kit/sorting/fraud_activity/";
    TestFileInput finput = getVectorizedFileInput(baseFilePath2 + "input03.txt");
    PRINT_INPUT_SIZE(finput);

    TestFileInput finput2 = getVectorizedFileInput(baseFilePath2 + "input04.txt");
    PRINT_INPUT_SIZE(finput2);

    int a = activityNotifications3({10, 20, 30, 40, 50}, 3);
    int b = activityNotifications3({2, 3, 4, 2, 3, 6, 8, 4, 5}, 5);
    int d = activityNotifications3({10, 20, 30, 40, 50}, 4);
    cout << "answers:: a: " << a << " b: " << b << " d:" << d << '\n';
    int c = activityNotifications3(finput.args, finput.params[1]);
    cout << "answers:: c: " << c << '\n';
    int e = activityNotifications3(finput.args, finput2.params[1]);
    cout << "answers:: e: " << e << '\n';
}